type Protocol @entity {
  id: ID! # autogenerated id
  userMintFee: BigInt! # Protocol fee for minting a profile id
  platformMintFee: BigInt! # Protocol fee for minting a platform id
  escrowFee: Int! # Protocol fee per escrow transaction (percentage, per 10,000)
  totalMintFees: BigInt! # Total mint fees collected
  shortHandlesMaxPrice: BigInt! # Maximum price for a short handle
}

type User @entity {
  id: ID! # Profile id
  createdAt: BigInt!
  updatedAt: BigInt!
  handle: String!
  address: String!
  platform: Platform # Platform where the profile was created
  cid: String # Uri of the description metadata
  description: UserDescription
  delegates: [String!]!
  rating: BigDecimal! # Average rating from reviews user has received
  reviews: [Review!] @derivedFrom(field: "to")
  numReviews: BigInt! # Number of reviews received by the user
  createdCourses: [Course!]! @derivedFrom(field: "seller") 
  purchasedCourses: [Course!]!
  totalGains: [UserGain!] @derivedFrom(field: "user")  # User total gains per token
}

type UserDescription @entity(immutable: true) {
  id: ID! # Uri
  title: String
  about: String
  timezone: BigInt
  headline: String
  country: String
  user: User!
  role: String # Learner, Teacher, Both
  name: String # Custom user name
  image_url: String 
  video_url: String
}

type Platform @entity {
  id: ID!
  address: Bytes! # Address of platform owner
  name: String!
  createdAt: BigInt!
  updatedAt: BigInt!
  originFee: Int! # Fee (percentage) asked by the platform for sales of courses created on the platform
  buyFee: Int! # Fee (percentage) asked by the platform for sales of courses purchased on the platform
  postingFee: BigInt! # Fee (flat) asked by the platform to post a course on the platform
  cid: String # Uri of the description metadata
  description: PlatformDescription
  signer: Bytes! # Address of the platform signer
  feePayments: [FeePayment!] @derivedFrom(field: "platform") # Fee payments to the platform
  totalPlatformGains: [PlatformGain!] @derivedFrom(field: "platform") # Platform total gains per token
  feeClaims: [FeeClaim!] @derivedFrom(field: "platform") # Platform fee claims
}

type PlatformDescription @entity(immutable: true) {
  id: ID! #cid
  about: String #text
  website: String #url
  platform: Platform!
  video_url: String
  image_url: String
}

type Course @entity {
  id: ID!
  createdAt: BigInt!
  updatedAt: BigInt!
  seller: User # User who created the course
  platform: Platform # Platform where the course was created
  token: Token!
  price: BigInt
  cid: String
  description: CourseDescription
  rating: BigDecimal! # Average rating from reviews course has received
  numReviews: BigInt! # Number of reviews received by the course
}

type CourseDescription @entity(immutable: true) {
  id: ID! # Uri
  course: Course!
  title: String
  about: String
  # keywords: [Keyword!] 
  keywords: [String!] 
  keywords_raw: String # Lowercase keywords in raw format, separated by comma
  image_url: String
  lessons: [Lesson!]! @derivedFrom(field: "course") 
}

type Lesson @entity(immutable: true) {
  id: ID! # Lesson id (concatenation of course id and lesson index in the course)
  course: CourseDescription!
  title: String
  about: String
  videoPlaybackId: String
}

type Review @entity(immutable: true) {
  id: ID! # Review token id
  createdAt: BigInt!
  course: Course!
  to: User! # Reviewed user
  from: User!
  rating: BigInt
  cid: String
  description: ReviewDescription
}

type ReviewDescription @entity(immutable: true) {
  id: ID!
  content: String
  review: Review
}

type Transaction @entity {
  id: ID!
  sender: User
  receiver: User
  token: Token!
  amount: BigInt!
  course: Course
  platform: Platform # Platform where the transaction was created
  protocolFee: Int! # Fee paid to the protocol
  originFee: Int! # Fee paid to the platform where the course was created
  buyFee: Int! # Fee paid to the platform where the course was being bought
  payment: Payment @derivedFrom(field: "transaction")
}

type Payment @entity(immutable: true) {
  id: ID!
  createdAt: BigInt
  paymentType: String
  transactionHash: String # Transaction hash of the transfer
  transaction: Transaction! # transaction entity
}

enum FeeType {
  OriginFee
  BuyFee
}

type FeePayment @entity(immutable: true) {
  id: ID! # Autogenerated id
  createdAt: BigInt
  platform: Platform
  course: Course
  type: FeeType! # Type of the fee
  token: Token
  amount: BigInt
}

type FeeClaim @entity(immutable: true) {
  id: ID! # Autogenerated id
  createdAt: BigInt
  platform: Platform
  token: Token 
  amount: BigInt!
  transactionHash: String # Transaction hash of the transfer
}

type Token @entity {
  id: ID! # Token id
  address: Bytes!
  symbol: String!
  name: String!
  decimals: BigInt!
  allowed: Boolean! # Whether the token is whitelisted or not
}

type PlatformGain @entity {
  id: ID! # Concatenation of platformId + token entity
  platform: Platform
  token: Token
  totalOriginFeeGain: BigInt! # Total gain for origin fee
  totalBuyFeeGain: BigInt! # Total gain for buy fee
}

type UserGain @entity {
  id: ID! # Concatenation of userId + token entity
  user: User
  token: Token
  totalGain: BigInt!
}

type Keyword @entity(immutable: true) {
  id: ID! #Keyword
  # Derived from does not currently work because of open issue with duplicated entities.
  # Reason: createOrGetKeyword creates duplicated keywords from file data source (ipfs-data.ts)
  # https://github.com/graphprotocol/graph-node/issues/4087
  # courseDescription: CourseDescription @derivedFrom(field: "keywords")
}